package calllog;
/*
 *  CallLog Jtapi Application
 *  Version 2.0     1/99
 *
 *  This JTAPI application, uses the core API along with some of the Avaya's
 *  extensions to the API to access functionality specific to Avaya's
 *  DEFINITY G3 PBX.
 *  This application has three purposes:
 *
 *  1) Observe a terminal to log all incoming and outgoing calls
 *     to/from the specified device.  It also displays UserToUser
 *     information associated with the call.
 *  2) The ability to make calls and send UserToUser information along
 *     with the call
 *  3) The ability to send DTMF through an active call
 *
 *  Options:
 *
 *  Tracing - when this option is enabled, all events received
 *            by the Call Listener on the terminal will be printed
 *            in the tracing area.
 *  Clear log - when this option is selected, the tracing and log area
 *              will be cleared.
 *
 *  To execute, type:
 *
 *  java CallLog
 *
 */

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.MenuShortcut;
import java.awt.Point;
import java.text.DateFormat;
import java.util.Date;
import java.util.Hashtable;

import javax.telephony.Address;
import javax.telephony.Call;
import javax.telephony.CallEvent;
import javax.telephony.CallListener;
import javax.telephony.Connection;
import javax.telephony.ConnectionEvent;
import javax.telephony.JtapiPeer;
import javax.telephony.JtapiPeerFactory;
import javax.telephony.JtapiPeerUnavailableException;
import javax.telephony.MetaEvent;
import javax.telephony.PlatformException;
import javax.telephony.Provider;
import javax.telephony.ProviderEvent;
import javax.telephony.ProviderListener;
import javax.telephony.Terminal;
import javax.telephony.TerminalConnection;
import javax.telephony.TerminalConnectionEvent;
import javax.telephony.callcontrol.CallControlConnectionEvent;
import javax.telephony.callcontrol.CallControlTerminalConnection;
import javax.telephony.callcontrol.CallControlTerminalConnectionEvent;
import javax.telephony.callcontrol.CallControlTerminalConnectionListener;
import javax.telephony.media.MediaTerminalConnection;

import com.avaya.jtapi.tsapi.LucentAddress;
import com.avaya.jtapi.tsapi.LucentCall;
import com.avaya.jtapi.tsapi.LucentCallInfo;
import com.avaya.jtapi.tsapi.LucentTerminal;
import com.avaya.jtapi.tsapi.UserToUserInfo;
@SuppressWarnings("deprecation")
public class CallLog extends Frame implements  ProviderListener, CallControlTerminalConnectionListener 
{
	private static final long serialVersionUID = 1L;

    // Used for addNotify check.
	boolean fComponentsAdjusted = false;
	
	//{{DECLARE_CONTROLS
	java.awt.Panel panel1 = new java.awt.Panel();
	//}}
	
	//{{DECLARE_MENUS
	java.awt.MenuBar mainMenuBar = new java.awt.MenuBar();
	java.awt.Menu fileMenu = new java.awt.Menu();
	java.awt.MenuItem loginMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem separatorMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem exitMenuItem = new java.awt.MenuItem();
	java.awt.Menu functionsMenu = new java.awt.Menu();
	java.awt.MenuItem callMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem dtmfMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem disconnectMenuItem = new java.awt.MenuItem();
	java.awt.Menu optionsMenu = new java.awt.Menu();
	java.awt.CheckboxMenuItem TracingMenuItem = new java.awt.CheckboxMenuItem("Tracing");
	java.awt.MenuItem clearLogMenuItem = new java.awt.MenuItem();
	//}}
	JtapiPeer       jtapiPeer;
	Provider        provider;
	Terminal        myTerminal;
	Address         myAddress;
	MyTextArea      trace;
	
	public CallLog()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		
		//{{INIT_CONTROLS
		setLayout(null);
		setSize(337,180);
		setVisible(false);
		panel1.setLayout(null);
		add(panel1);
		panel1.setBounds(0,0,334,179);
		setTitle("JTAPI Call Log");
	    //}}
		trace = new MyTextArea();
		trace.setBounds(0,0,399,169);
		panel1.add(trace);
		
		//{{INIT_MENUS
		fileMenu.setLabel("File");
		fileMenu.add(loginMenuItem);
		loginMenuItem.setLabel("Login...");
		loginMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_L,false));
		fileMenu.add(separatorMenuItem);
		separatorMenuItem.setLabel("-");
		fileMenu.add(exitMenuItem);
		exitMenuItem.setLabel("Exit");
		mainMenuBar.add(fileMenu);
		functionsMenu.setLabel("Functions");
		functionsMenu.add(callMenuItem);
		callMenuItem.setLabel("Make call with UUI...");
		callMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_C,false));
		functionsMenu.add(dtmfMenuItem);
		dtmfMenuItem.setLabel("Send DTMF...");
		dtmfMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_S,false));
		functionsMenu.add(disconnectMenuItem);
		disconnectMenuItem.setLabel("Disconnect call");
		disconnectMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_D,false));
		mainMenuBar.add(functionsMenu);
		optionsMenu.setLabel("Options");
		TracingMenuItem.setLabel("Tracing");
		TracingMenuItem.setState(false);
		optionsMenu.add(TracingMenuItem);
		optionsMenu.add(clearLogMenuItem);
		clearLogMenuItem.setLabel("Clear Log");
		mainMenuBar.add(optionsMenu);
		//$$ mainMenuBar.move(1,230);
		setMenuBar(mainMenuBar);
		//}}
		functionsMenu.setEnabled(false);
		
		//{{REGISTER_LISTENERS
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		SymComponent aSymComponent = new SymComponent();
		this.addComponentListener(aSymComponent);
		SymAction lSymAction = new SymAction();
		exitMenuItem.addActionListener(lSymAction);
		loginMenuItem.addActionListener(lSymAction);
		callMenuItem.addActionListener(lSymAction);
		disconnectMenuItem.addActionListener(lSymAction);
		dtmfMenuItem.addActionListener(lSymAction);
		SymItem lSymItem = new SymItem();
		TracingMenuItem.addItemListener(lSymItem);
		clearLogMenuItem.addActionListener(lSymAction);
		//}}

		//obtain the JtapiPeer object
		if ( !initJtapi() ) {
		    trace.append( "Error: JtapiPeer could not be created.  Verify your Jtapi client install.\n\n");
	        loginMenuItem.setEnabled(false);
	        return;
	    }
	    try {
			// LoginDialog Create and show as modal
			(new LoginDialog(this, true, getServices())).setVisible(true);
		} catch (Exception e) {
		}
	}
	
	public CallLog(String title)
	{
		this();
		setTitle(title);
	}
	
    /**
     * Shows or hides the component depending on the boolean flag b.
     * @param b  if true, show the component; otherwise, hide the component.
     * @see java.awt.Component#isVisible
     */
    public void setVisible(boolean b)
	{
		if(b)
		{
			setLocation(50, 50);
		}	
		super.setVisible(b);
	}
	
	static public void main(String args[])
	{
		try
		{
			//Create a new instance of our application's frame, and make it visible.
    		(new CallLog()).setVisible(true);
		}
		catch (Throwable t)
		{
			System.err.println(t);
			t.printStackTrace();
			//Ensure the application exits with an error condition.
			System.exit(1);
		}
	}
	
	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension d = getSize();
		
		super.addNotify();
	
		if (fComponentsAdjusted)
			return;
	
		// Adjust components according to the insets
		setSize(getInsets().left + getInsets().right + d.width, getInsets().top + getInsets().bottom + d.height);
		Component components[] = getComponents();
		for (int i = 0; i < components.length; i++)
		{
			Point p = components[i].getLocation();
			p.translate(getInsets().left, getInsets().top);
			components[i].setLocation(p);
		}
		fComponentsAdjusted = true;
	}
	
	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == CallLog.this)
				CallLog_WindowClosing(event);
		}
	}
	
	void CallLog_WindowClosing(java.awt.event.WindowEvent event)
	{
		try {
			// QuitDialog Create and show as modal
			(new QuitDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}
	
	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == exitMenuItem)
				exitMenuItem_ActionPerformed(event);
			else if (object == loginMenuItem)
				loginMenuItem_ActionPerformed(event);
			else if (object == callMenuItem)
				callMenuItem_ActionPerformed(event);
			else if (object == disconnectMenuItem)
				disconnectMenuItem_ActionPerformed(event);
			else if (object == dtmfMenuItem)
				dtmfMenuItem_ActionPerformed(event);
			else if (object == clearLogMenuItem)
				clearLogMenuItem_ActionPerformed(event);
		}
	}
	
	class SymComponent extends java.awt.event.ComponentAdapter
	{
		public void componentResized(java.awt.event.ComponentEvent event)
		{
			Object object = event.getSource();
			if (object == CallLog.this)
				CallLog_ComponentResized(event);
		}
	}

	void CallLog_ComponentResized(java.awt.event.ComponentEvent event)
	{
		try {
			Dimension size = this.getSize();
			panel1.setSize(size);
    	    trace.setSize( size.width - 8, size.height - 46);
		} catch (Exception e) {
		}
	}

	void loginMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		
		if ( "Login...".equals (loginMenuItem.getLabel()) ) {
		    try {
			    // LoginDialog Create and show as modal
			    (new LoginDialog(this, true, getServices())).setVisible(true);
		    } catch (Exception e) {
		    }
		} else {
		    logout();
		}
	}
	
	void exitMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		try {
			// QuitDialog Create and show as modal
		    (new QuitDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}
	
	void callMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		try {
			// MakeCallDialog Create and show as modal
			(new MakeCallDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}

	void disconnectMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		try {
			this.disconnect();
		} catch (Exception e) {
		}
	}

	void dtmfMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		try {
			// DTMFDialog Create and show as modal
			(new DTMFDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}

	class SymItem implements java.awt.event.ItemListener
	{
		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == TracingMenuItem)
				TracingMenuItem_ItemStateChanged(event);
		}
	}

	void TracingMenuItem_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		try {
			// TracingMenuItem Check the CheckboxMenuItem on condition; TracingMenuItem Is CheckboxMenuItem not checked?
			trace.setState(TracingMenuItem.getState());
		} catch (Exception e) {
		}
	}
		
	void clearLogMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		trace.clear();
	}
	
   /**
    * This method creates the default JtapiPeer.
    */
    public boolean initJtapi() 
    {
        try {
		    //get default implementation of the JtapiPeer object by sending null,
		    //optionally you may send com.avaya.jtapi.tsapi.TsapiPeer
		    jtapiPeer = JtapiPeerFactory.getJtapiPeer( null );
		    trace.append( false, "JtapiPeer created successfully.\n\n");
        } catch (JtapiPeerUnavailableException e) {
	        try{
			jtapiPeer = JtapiPeerFactory.getJtapiPeer( "com.avaya.jtapi.tsapi.TsapiPeer" );
			trace.append( false, "JtapiPeer created successfully.\n\n");
		} catch (JtapiPeerUnavailableException e2) {
			trace.append( "JtapiPeerFactory.getJtapiPeer: caught JtapiPeerUnavailableException\n");
	        	trace.append( "Message: " + e2.getMessage() + "\n\n" );
	        	trace.append( "Error: JtapiPeer could not be created.  Verify your Jtapi client install.\n\n");
            		return false;
		}
	}
	    
	return true;
    }
    
    public String[] getServices() 
    {
	    String[]   services = null;

        try {
		    // get service providers on the network -- this depends on 
	        // the administration in the tsapi.pro file
			services = jtapiPeer.getServices();
		}
		catch (PlatformException e) {
	        trace.append( "JtapiPeer.getServices(): caught PlatformException\n" );
            trace.append( "Message: " + e.getMessage() + "\n\n" );
	        e.printStackTrace();
	        return null;
	    }
	    return services;
	}
    	
   /**
    * This method creates the Provider and waits until is in service.
    */
    public synchronized void login(Hashtable<String, String> args) 
    {
        String          serviceName;
        String          login;
        String          password;
        String          callingExt;
        String          providerString;

        serviceName = (String) args.get("serviceName");
		login = (String) args.get("login");
		password = (String) args.get("password");
        callingExt  = (String) args.get( "callingExt" );
        
		providerString = serviceName + ";loginID=" + login + ";passwd=" + password;

		if ( jtapiPeer == null ) {
		    return;
		}
		    
		try {       
		    // create provider
			provider = jtapiPeer.getProvider(providerString);
			trace.append( false, "Provider created successfully.\n\n");
			trace.append( false, "Waiting for the provider to initialize...\n");
		        
		    //add a Provider Listener to the provider
		    provider.addProviderListener( this );
	            
	        // wait to be notified when the provider is in service --
	        // corresponding notify is in the providerChangedEvent() method
	        wait ();                                          
		} catch (Exception e) {
    	    trace.append( "login() caught " + e + "\n");
    	    trace.append( "Message: " + e.getMessage() + "\n\n" );
            trace.append( "Please verify that the login information is correct.\n\n" );
    	    return;
    	} 
            			
		trace.append( false, "Provider is in service.\n\n" ); 
		        
        try {
            try {
                //In order to make a call, we need to obtain an Address and a Terminal
                //object that represent the dialing extension.  In Avaya's implementation
                //of JTAPI, there is a one-to-one relationship between the Terminal and 
                //Address objects that represent an extension number.
                    
                // create Address
                myAddress = provider.getAddress( callingExt );
                trace.append( false, "Address " + callingExt + " created successfully.\n\n");
                    
                // create Terminal
        	    myTerminal = provider.getTerminal(callingExt);
        	    trace.append( false, "Terminal " + callingExt + " created successfully.\n\n");
            } catch (Exception e) {
    	        trace.append( "Please verify that the dialing extension number is correct.\n\n" );
    	        throw (e);
    	    }
                    
            trace.append( false, "Adding a call listener to the terminal.\n\n");

            // add call listener to terminal
            myTerminal.addCallListener( this );
    	    
    	} catch (Exception e) {
    	    trace.append( "login() caught " + e + "\n");
    	    trace.append( "Message: " + e.getMessage() + "\n\n" );
            handleProviderShutdown();
            return;
    	}   	      
    }
    
   /**
    * makeCall() - makes a call with UserToUserInfo to specified device
    * This method creates  the Call object and uses the connect() method
    * from the LucentCall interface to place the call to the destination
    * number with any UUI specified.
    */
    public void makeCall( Hashtable<String, String> args ) 
    {
        String                  calledNumber;
        String                  uui;
        Call                    call = null;
        UserToUserInfo          avayaUUI = null;

		calledNumber = (String) args.get("calledNumber");
        uui = (String) args.get("uui");

        // create UserToUserInfo object
        if ( uui != null ) {
            avayaUUI = new UserToUserInfo( uui );
        }

        try {
            // create Call object
            call = provider.createCall();
        } catch (Exception e) {
    	    trace.append( "makeCall() caught " + e + "\n");
    	    trace.append( "Message: " + e.getMessage() + "\n\n" );
            return;
    	} 


        try {
    	    // makecall by using the connect method in the LucentCall interface
            ( (LucentCall) call).connect( 
                                                        (LucentTerminal) myTerminal, 
                                                        (LucentAddress) myAddress, 
                                                        calledNumber, 
                                                        false, 
                                                        avayaUUI);
    	} catch (Exception e) {
    	    trace.append( "makecall() caught " + e + "\n");
    	    trace.append( "Message: " + e.getMessage() + "\n\n" );
            return;
    	} 
    }
    
    /**
    * This method sends DTMF on active call (in the TALKING state).
    * It uses the getTerminalConnections method of the Terminal interface
    * to get a handle on the connection that is in the TALKING state.  When a connection
    * is found, then uses the generateDtmf method of the MediaTerminalConnection
    * interface to send DTMF.
    */

	public void sendDTMF( String dtmf ) 
    {
		TerminalConnection[]    terminalConnections = null;
		boolean                 found = false;

        try {
            terminalConnections = myTerminal.getTerminalConnections();
            
            if ( terminalConnections != null ) {
            
                for (int i=0; i < terminalConnections.length; i++ ) {
                    
                    if (  (( CallControlTerminalConnection) terminalConnections[i]).getCallControlState() ==
                        CallControlTerminalConnection.TALKING ) {
                            
                        found = true;
                        try {
                            ((MediaTerminalConnection) terminalConnections[i]).generateDtmf( dtmf );
                            trace.append("DTMF '" + dtmf + 
                            		"' sent successfully");
                        } catch (Exception e) {
    	                    trace.append("sendDTMF() caught " + e + "\n");
    	                    trace.append( "Message: " + e.getMessage() + "\n\n" );
                            trace.append( "Accepted values are 0-9, '#' and '*'.\n\n" );
                            return;
    	                }
                    }
                }
            }
            
            if ( !found ) {
                trace.append ( "There are no connections in the 'talking' state\n\n" );
            }
            
        } catch (Exception e) {
    	    trace.append("sendDTMF() caught " + e + "\n");
    	    trace.append( "Message: " + e.getMessage() + "\n\n" );
            return;
    	}
    }

   /**
    * This method disconnects active call (in the TALKING state).
    * It uses the getTerminalConnections method of the Terminal interface.
    * If there is only one terminalConnection, terminate that one.  Otherwise,
    * get a handle on the connection that is in the TALKING state.  When a connection
    * is found, then calls the disconnect(connection) method to end the call.
    */
    public void disconnect() 
    {
		TerminalConnection[]     terminalConnections = null;
		boolean                  found = false;
		Connection               connection;

        try {
            terminalConnections = myTerminal.getTerminalConnections();
        }
        catch ( PlatformException e ) {
            trace.append ( "Terminal.getTerminalConnections() caught PlatformException\n" );
            trace.append( "Message: " + e.getMessage() + "\n\n" );
	        e.printStackTrace();
        }

        if ( terminalConnections != null ) {

            if ( terminalConnections.length == 1 ) {

                connection = terminalConnections[0].getConnection();
                disconnect ( connection );

            } else {
                for ( int i=0; i < terminalConnections.length; i++ ) {

                    if ( ( (CallControlTerminalConnection) terminalConnections[i]).getCallControlState() ==
                         CallControlTerminalConnection.TALKING ) {

                        found = true;
                        connection = terminalConnections[i].getConnection();

                        disconnect ( connection );
                    }
                }
                if ( !found ) {
                    trace.append ( "There are no Connections in the Talking state\n\n" );
                }
            }
        }
    }

   /**
    * This method disconnects the connection passed in the argument.
    * It uses the disconnect method of the Connection interface to end the call.
    */
    public void disconnect( Connection connection ) 
    {
        if ( connection != null ) {

            try {
                connection.disconnect();
                trace.append("Successfully disconnected connection at address '" + connection.getAddress().getName() + "'");
            } catch (Exception e) {
    	        trace.append("Connection.disconnect() caught " + e + "\n");
    	        trace.append( "Message: " + e.getMessage() + "\n\n" );
                return;
    	    }
        }
    }
    
    /**
    * This method executes a Provider shutdown.
    * It first verifies that the Provider is in service, it then removes the
    * call listener that we have on the terminal, and then uses the shutdown method
    * on the Provider to terminate session.
    */
    public void logout() 
    {
        if (provider != null ) {

		    if ( provider.getState() == Provider.IN_SERVICE ) {

                // remove call listener on terminal (nice but not necessary)
                if ( myTerminal != null ) {
                    try {
                        CallListener listeners[] = myTerminal.getCallListeners();

                        if ( listeners != null ) {

                            for ( int i=0; i < listeners.length; i++ ) {
                                myTerminal.removeCallListener( listeners[i] );
                            }
                        }
                    } catch (Exception e) {
    	                trace.append( "logout() caught " + e + "\n");
    	                trace.append( "Message: " + e.getMessage() + "\n\n" );
                        return;
    	            }   	
                }

                // shutdown Provider
                trace.append( false, "Shutting down provider...\n\n");
        		try {
        		    provider.shutdown();
        		} catch (Exception e) {
    	            trace.append( "logout() caught " + e + "\n");
    	            trace.append( "Message: " + e.getMessage() + "\n\n" );
                    return;
    	        }   	
            }
            provider = null;
        }
	}

   /**
    * This method resets the menus when there is a connection active.
    * It enables the "Send DTMF" and the "Disconnect" menu
    * items and disables the "Make Call with UUI" menu item
    */
    public void handleConnActive() 
    {
        dtmfMenuItem.setEnabled(true);
        disconnectMenuItem.setEnabled(true);
        callMenuItem.setEnabled(false);
    }

   /**
    * This method resets the menu when a connection has been dropped.
    * It disables the "Send DTMF" and the "Disconnect" menu
    * items; enable the "Make Call with UUI" menu item
    */
    public void handleConnDropped() 
    {
        dtmfMenuItem.setEnabled(false);;
        disconnectMenuItem.setEnabled(false);
        callMenuItem.setEnabled(true);
    }

   /**
    * This method logs a call made from the terminal.
    * When a call has been placed from our observed terminal, record:
    *   - date and time call was placed
    *   - the called device information
    *   - UserToUserInfo sent, if any,  by using the getUserToUserInfo method in the
    *     LucentCallInfo interface.
    * Note that this method will be called for two specific events:
    *   - CallCtlConnAlertingEv - to track when connection is alerting at terminating
    *                             end of the call for internal calls
    *   - CallCtlConnNetworkReachedEv - to track when connection has reached the network
    *                             for external calls, in this case the UUI is not available
    */
    public void handleOutgoingCall( CallControlConnectionEvent event ) 
    {
        Terminal        callingTerminal;
		Address         callingAddress;
        Address         calledAddress;
        UserToUserInfo  avayaUUI = null;
        String          calledNumber = "<Unknown>";
        Address         address;
        Call            call;
        String          name = "";

        try {
            callingTerminal = event.getCallingTerminal();

            // first verify that the callingTerminal is our terminal
            if ( myTerminal.equals ( callingTerminal ) ) {

                address = event.getConnection().getAddress();
                callingAddress = event.getCallingAddress();
		        calledAddress = event.getCalledAddress();

                if ( address != null && callingAddress != null ) {

                    // verify if this CallCtlCallEv belongs to the terminating end of the call
                    if ( !( address.equals ( callingAddress ) ) ) {

                        Date d = new Date();

                        // get called number information
                        if ( calledAddress != null ) {
                            calledNumber = calledAddress.getName();
                        }
                        
                        // get called number information
                        if ( calledAddress instanceof LucentAddress ) {
                            
                            try {
                                name = ( (LucentAddress) calledAddress).getDirectoryName();
                            } 
                            catch ( Exception e ) {}                           
                        }
                        
                        if ( name == null ) {
                            name = calledNumber;
                        }

                        // log call
                        trace.append( DateFormat.getDateTimeInstance().format(d) + " Call made to: " + name + " [" + calledNumber + "]");

            		    call = event.getCall();
            		    // verify if there is UUI along with this call
            		    if ( call instanceof LucentCallInfo ) {

            		        if ( event.getID() == CallControlConnectionEvent.CALLCTL_CONNECTION_NETWORK_REACHED ) {
            		            trace.append("  UUI: <unknown>\n\n");
            		        } else {
            		            avayaUUI = ( (LucentCallInfo) call ).getUserToUserInfo();
                		        if ( avayaUUI != null ) {
                		            String uui = avayaUUI.getString();
                		            trace.append("  UUI: " + uui + "\n\n");
                		        } else {
                		            trace.append("  UUI: <none>\n\n");
                		        }
                		    }
            		    }
        		    }
        	    }
            }
        } catch (Exception e) {
    	    trace.append( "handleOutgoingCall() caught " + e + "\n");
    	    trace.append( "Message: " + e.getMessage() + "\n\n" );
            return;
    	}   
    }

   /**
    * This method logs incoming calls.
    * When a call has been received by our observed terminal, record:
    *   - date and time call was received
    *   - the calling device information
    *   - UserToUserInfo received, if any,  by using the getUserToUserInfo method in the
    *     LucentCallInfo interface.
    * Note that this method will be called for two specific events:
    *   - CallControlTermConnRingingEv - to track when calls are alerting at our observed
    *                                    terminal
    */
    public void handleIncomingCall(CallControlTerminalConnectionEvent event ) {

        Address         callingAddress;
        UserToUserInfo  avayaUUI = null;
        String          uui = null;
        String          name = null;
        Date            d = new Date();
	            
	    callingAddress = event.getCallingAddress();

        if ( event instanceof LucentCallInfo ) {
                
	        avayaUUI = ( (LucentCallInfo) event ).getUserToUserInfo();
	        
		    if ( avayaUUI != null ) {
		        uui = "  UUI: " + avayaUUI.getString() + "\n\n";
		    } else {
		        uui = "  UUI: <none>\n\n";
		    }
		}

        if ( callingAddress != null ) {

	        // verify that callingAddress is not our address, otherwise, it is us
            // initiating the call
            if ( !( myAddress.equals( callingAddress )) ) {
                    
                name = null;
                    
                // get called number information
                if ( callingAddress instanceof LucentAddress ) {
                    
                    try {
	                    name = ( (LucentAddress) callingAddress).getDirectoryName();
                    } catch (Exception e) {}
    	        }   
                    
                if ( name == null ) {
                    name = callingAddress.getName();
                }

                trace.append( DateFormat.getDateTimeInstance().format(d) + " Call received from: " +
                                                        name + uui);
            }
        } else {
            trace.append( DateFormat.getDateTimeInstance().format(d) + " Call received from: <Unknown>" + uui);
        }
    }
    
   /**
    * This method does the necessary initialization for our application, 
    * when the provider has been created and is in service.
    */
    public synchronized void handleProviderInService() {

        notify();
        int index = (provider.getName()).indexOf (";log", 0);
        setTitle("JTAPI Call Log " + (provider.getName()).substring (0, index));
        trace.append( "Service provider is in service.\n\n");
        loginMenuItem.setLabel("Logout");
        functionsMenu.setEnabled(true);
        dtmfMenuItem.setEnabled(false);
        disconnectMenuItem.setEnabled(false);
        callMenuItem.setEnabled(true);
    }

   /**
    * This method does the necessary clean-up for our application, 
    * when the session has been terminated.
    */
    public void handleProviderShutdown() {

        provider = null;
        loginMenuItem.setLabel("Login...");
        functionsMenu.setEnabled(false);
        trace.append( "Service provider is shut down.\n\n" );
    }

	public void providerInService(ProviderEvent arg0) {
		handleProviderInService();
	}

	public void providerShutdown(ProviderEvent arg0) {
		handleProviderShutdown();
	}

	public void terminalConnectionRinging(CallControlTerminalConnectionEvent arg0) {
		handleConnActive ();
        handleIncomingCall (arg0);
	}

	public void connectionAlerting(CallControlConnectionEvent arg0) {
		handleOutgoingCall(arg0);
	}

	public void connectionNetworkReached(CallControlConnectionEvent arg0) {
		 handleOutgoingCall (arg0);
	}
	
	public void terminalConnectionActive(TerminalConnectionEvent arg0) {
		handleConnActive();
	}

	public void terminalConnectionDropped(TerminalConnectionEvent arg0) {
		handleConnDropped();
	}
	
	//no-op implementations
	public void providerOutOfService(ProviderEvent arg0) {
		//NO-OP	
	}
	
	public void terminalConnectionBridged(CallControlTerminalConnectionEvent arg0) {
		//NO-OP	
	}

	public void providerEventTransmissionEnded(ProviderEvent arg0) {
		//NO-OP	
	}
	
	public void terminalConnectionDropped(CallControlTerminalConnectionEvent arg0) {
		//NO-OP		
	}

	public void terminalConnectionHeld(CallControlTerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionInUse(CallControlTerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionTalking(CallControlTerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionUnknown(CallControlTerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionDialing(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionDisconnected(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionEstablished(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionFailed(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionInitiated(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionNetworkAlerting(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionOffered(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionQueued(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionUnknown(CallControlConnectionEvent arg0) {
		//NO-OP
	}

	public void callActive(CallEvent arg0) {
		//NO-OP
	}

	public void callEventTransmissionEnded(CallEvent arg0) {
		//NO-OP
	}

	public void callInvalid(CallEvent arg0) {
		//NO-OP
	}

	public void multiCallMetaMergeEnded(MetaEvent arg0) {
		//NO-OP
	}

	public void multiCallMetaMergeStarted(MetaEvent arg0) {
		//NO-OP
	}

	public void multiCallMetaTransferEnded(MetaEvent arg0) {
		//NO-OP
	}

	public void multiCallMetaTransferStarted(MetaEvent arg0) {
		//NO-OP
	}

	public void singleCallMetaProgressEnded(MetaEvent arg0) {
		//NO-OP
	}

	public void singleCallMetaProgressStarted(MetaEvent arg0) {
		//NO-OP
	}

	public void singleCallMetaSnapshotEnded(MetaEvent arg0) {
		//NO-OP
	}

	public void singleCallMetaSnapshotStarted(MetaEvent arg0) {
		//NO-OP
	}

	public void connectionAlerting(ConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionConnected(ConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionCreated(ConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionDisconnected(ConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionFailed(ConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionInProgress(ConnectionEvent arg0) {
		//NO-OP
	}

	public void connectionUnknown(ConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionCreated(TerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionPassive(TerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionRinging(TerminalConnectionEvent arg0) {
		//NO-OP
	}

	public void terminalConnectionUnknown(TerminalConnectionEvent arg0) {
		//NO-OP
	}
}